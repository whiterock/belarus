start with welcome message:


push welcome message as list to stack
" -> output

loop here ??

(input please) "



done.

how to show stack contents:
	copy everything and print then? 

	we need a loop for this.


a) how to loop
	just copy the input all the times
b) how to print stack values
	need to keep track of how many values are on the stack huh?



oh apply later and # stack size seem really handy.


(nah dis doznt work.)
stack should always be 

rest here?
(2!@)\   replicate last above
(input) at bottom


Conditionals:

C = 4!4$1+$@
A = 3!3!1-2!1=4!()(C)@2$*

this gets executed.
3(A)3!3$3!@2$

3(3!3!1-2!1=4!()(4!4$1+$@)@2$*)3!3$3!@2$

puts 3 and (A) on stack
then copies the 3 from bottom and puts it up top.
then copies A from bottom to create (A) 3 (A)
then executes A and the (2$) is there to multiply later by two and delete the A left on bot of stack

we dont need the latter part do we. just rearranges the stack, we dont mind :)

we just want to have (B)2!@ to keep out REPL on bot of stack :)

(A puts itself back on the stack as its first action.)
(we want a subroutine that prints stack like this, that puts itself on the stack.)


(is having P on top of stack the only option?), yes.

(1)(2)(3)(4)(P)2!@

what does P do? 

	(copy element under P to top of stack and print)
1) (3!3$"#2-3!()(4!4$1+$@)@)


B = <some logic> (quit)()


recursion is the only way to go.
how does recursion work?
we put itself on the stack and execute.


but what gets executed? whats the order? 

((Input:)\"')2!@
order should be:

check stack size,
branch to either (print and copy)
or (copy input and execute)


P = (#2-(3!3$\"2!@)(3!@)(4!4$1+$@))




how bout this:


ect.
(P) 	print stack and recursion
(Input:) + logic here

in building the recursion it adds more *2$ cus its A num A num A num num


(2!@)

copy bottom of stack and execute.
A puts itself ontop of the stack, then true, then conditional!


stack:

(C)
(true)
(false)
bool	(careful, check puts 1 if 0,  and 0 if otherwise) (i prolly dont have to check tbh)


#1-?("(#1-?(")(2!@))@)(2!@)(4!4$1+$@)

leere klammer wird (2!@) -> copy bottom of stack and execute (such that we never stop.)

"(Bienvenue!)\"
((Input:)\"'@#1-?(\"(#1-?(\"(#1-?(\")(2!@))@)
(2!@)
(4!4$1+$@))
2!@(2!@)\\"



(Input + execute)
(Loop) does the following: copy the thing below, depending on stack size execute or delete and print? 
(Input + execute)
